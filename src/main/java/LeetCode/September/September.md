## 9.10每日一题
#### [669. 修剪二叉搜索树](trimBST.java)
给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。



    示例 1：
    
    
    输入：root = [1,0,2], low = 1, high = 2
    输出：[1,null,2]
    示例 2：
    
    
    输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
    输出：[3,2,null,1]


提示：

树中节点数在范围 [1, 104] 内
0 <= Node.val <= 104
树中每个节点的值都是 唯一 的
题目数据保证输入是一棵有效的二叉搜索树
0 <= low <= high <= 104

## 9.11每日一题
#### [857. 雇佣 K 名工人的最低成本](mincostToHireWorkers.java)

有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。

现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资：

对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。
工资组中的每名工人至少应当得到他们的最低期望工资。
给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 。在实际答案的 10-5 以内的答案将被接受。。



    示例 1：
    
    输入： quality = [10,20,5], wage = [70,50,30], k = 2
    输出： 105.00000
    解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。
    示例 2：
    
    输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3
    输出： 30.66667
    解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。
 

## 9.13每日一题
#### [670. 最大交换](maximumSwap.java)
给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。

    示例 1 :
    
    输入: 2736
    输出: 7236
    解释: 交换数字2和数字7。
    示例 2 :
    
    输入: 9973
    输出: 9973
    解释: 不需要交换。

## 9.14 每日一题
#### [1619. 删除某些元素后的数组均值](trimMean.java)
给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。

与 标准答案 误差在 10-5 的结果都被视为正确结果。



    示例 1：
    
    输入：arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]
    输出：2.00000
    解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。
    示例 2：
    
    输入：arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]
    输出：4.00000
    示例 3：
    
    输入：arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]
    输出：4.77778
    示例 4：
    
    输入：arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]
    输出：5.27778
    示例 5：
    
    输入：arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]
    输出：5.29167

## 9.15每日一题
#### [672. 灯泡开关 Ⅱ](flipLights.java)
房间中有 n 只已经打开的灯泡，编号从 1 到 n 。墙上挂着 4 个开关 。

这 4 个开关各自都具有不同的功能，其中：

    开关 1 ：反转当前所有灯的状态（即开变为关，关变为开）
    开关 2 ：反转编号为偶数的灯的状态（即 2, 4, ...）
    开关 3 ：反转编号为奇数的灯的状态（即 1, 3, ...）
    开关 4 ：反转编号为 j = 3k + 1 的灯的状态，其中 k = 0, 1, 2, ...（即 1, 4, 7, 10, ...）
你必须 恰好 按压开关 presses 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。

给你两个整数 n 和 presses ，执行完所有按压之后，返回 不同可能状态 的数量。
~~~
示例 1：

输入：n = 1, presses = 1
输出：2
解释：状态可以是：
- 按压开关 1 ，[关]
  - 按压开关 2 ，[开]
    示例 2：

输入：n = 2, presses = 1
输出：3
解释：状态可以是：
- 按压开关 1 ，[关, 关]
  - 按压开关 2 ，[开, 关]
  - 按压开关 3 ，[关, 开]
    示例 3：

输入：n = 3, presses = 1
输出：4
解释：状态可以是：
- 按压开关 1 ，[关, 关, 关]
  - 按压开关 2 ，[关, 开, 关]
  - 按压开关 3 ，[开, 关, 开]
  - 按压开关 4 ，[关, 开, 开]
~~~
## 9.16每日一题
#### [850. 矩形面积 II](rectangleArea.java)
我们给出了一个（轴对齐的）二维矩形列表 rectangles 。 对于 rectangle[i] = [x1, y1, x2, y2]，其中（x1，y1）是矩形 i 左下角的坐标， (xi1, yi1) 是该矩形 左下角 的坐标， (xi2, yi2) 是该矩形 右上角 的坐标。

计算平面中所有 rectangles 所覆盖的 总面积 。任何被两个或多个矩形覆盖的区域应只计算 一次 。

返回 总面积 。因为答案可能太大，返回 109 + 7 的 模 。



示例 1：



输入：rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
输出：6
解释：如图所示，三个矩形覆盖了总面积为6的区域。
从(1,1)到(2,2)，绿色矩形和红色矩形重叠。
从(1,0)到(2,3)，三个矩形都重叠。
示例 2：

输入：rectangles = [[0,0,1000000000,1000000000]]
输出：49
解释：答案是 1018 对 (109 + 7) 取模的结果， 即 49 。

## 9.17每日一题
#### [1624. 两个相同字符之间的最长子字符串](maxLengthBetweenEqualCharacters.java)
给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。

子字符串 是字符串中的一个连续字符序列。
    示例 1：
    
    输入：s = "aa"
    输出：0
    解释：最优的子字符串是两个 'a' 之间的空子字符串。
    示例 2：
    
    输入：s = "abca"
    输出：2
    解释：最优的子字符串是 "bc" 。
    示例 3：
    
    输入：s = "cbzxy"
    输出：-1
    解释：s 中不存在出现出现两次的字符，所以返回 -1 。
    示例 4：
    
    输入：s = "cabbac"
    输出：4
    解释：最优的子字符串是 "abba" ，其他的非最优解包括 "bb" 和 "" 。
## [827. 最大人工岛](largestIsland.java)
给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。

返回执行此操作后，grid 中最大的岛屿面积是多少？

岛屿 由一组上、下、左、右四个方向相连的 1 形成。



    示例 1:
    
    输入: grid = [[1, 0], [0, 1]]
    输出: 3
    解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。
    示例 2:
    
    输入: grid = [[1, 1], [1, 0]]
    输出: 4
    解释: 将一格0变成1，岛屿的面积扩大为 4。
    示例 3:
    
    输入: grid = [[1, 1], [1, 1]]
    输出: 4
    解释: 没有0可以让我们变成1，面积依然为 4。

## 9.19每日一题
### [1636. 按照频率将数组升序排序](frequencySort.java)
给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。

请你返回排序后的数组。



    示例 1：
    
    输入：nums = [1,1,2,2,2,3]
    输出：[3,1,1,2,2,2]
    解释：'3' 频率为 1，'1' 频率为 2，'2' 频率为 3 。
    示例 2：
    
    输入：nums = [2,3,1,3,2]
    输出：[1,3,3,2,2]
    解释：'2' 和 '3' 频率都为 2 ，所以它们之间按照数值本身降序排序。
    示例 3：
    
    输入：nums = [-1,1,-6,4,5,-6,1,4,1]
    输出：[5,-1,4,4,-6,-6,1,1,1]
 
## 9.20每日一题
#### [698. 划分为k个相等的子集](canPartitionKSubsets.java)
给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。



    示例 1：
    
    输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
    输出： True
    说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
    示例 2:
    
    输入: nums = [1,2,3,4], k = 3
    输出: false
     