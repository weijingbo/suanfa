## 9.10每日一题
#### [669. 修剪二叉搜索树](trimBST.java)
给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。



    示例 1：
    
    
    输入：root = [1,0,2], low = 1, high = 2
    输出：[1,null,2]
    示例 2：
    
    
    输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
    输出：[3,2,null,1]


提示：

树中节点数在范围 [1, 104] 内
0 <= Node.val <= 104
树中每个节点的值都是 唯一 的
题目数据保证输入是一棵有效的二叉搜索树
0 <= low <= high <= 104

## 9.11每日一题
#### [857. 雇佣 K 名工人的最低成本](mincostToHireWorkers.java)

有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。

现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资：

对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。
工资组中的每名工人至少应当得到他们的最低期望工资。
给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 。在实际答案的 10-5 以内的答案将被接受。。



    示例 1：
    
    输入： quality = [10,20,5], wage = [70,50,30], k = 2
    输出： 105.00000
    解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。
    示例 2：
    
    输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3
    输出： 30.66667
    解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。
 

## 9.13每日一题
#### [670. 最大交换](maximumSwap.java)
给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。

示例 1 :

输入: 2736
输出: 7236
解释: 交换数字2和数字7。
示例 2 :

输入: 9973
输出: 9973
解释: 不需要交换。

